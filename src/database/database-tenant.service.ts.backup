import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as pg from 'pg';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class DatabaseTenantService {
  private logger = new Logger(DatabaseTenantService.name);
  private pool: pg.Pool;

  constructor(private configService: ConfigService) {
    this.pool = new pg.Pool({
      user: this.configService.get<string>('DB_USER') || 'hrapp',
      password: this.configService.get<string>('DB_PASSWORD') || 'hrapp123',
      host: this.configService.get<string>('DB_HOST') || 'localhost',
      port: this.configService.get<number>('DB_PORT') || 5432,
      database: 'postgres', // Connect to default postgres database for admin operations
    });
  }

  async createTenantDatabase(
    tenantSlug: string,
    seedData?: {
      email: string;
      firstName: string;
      lastName: string;
      password: string;
      role: string;
    },
  ): Promise<void> {
    const databaseName = `${tenantSlug}_erp`;
    const client = await this.pool.connect();

    try {
      // Check if database already exists
      const result = await client.query(
        `SELECT 1 FROM pg_database WHERE datname = $1`,
        [databaseName],
      );

      if (result.rows.length > 0) {
        this.logger.warn(`Database ${databaseName} already exists`);
        return;
      }

      // Create database
      await client.query(`CREATE DATABASE "${databaseName}"`);
      this.logger.log(`Database ${databaseName} created successfully`);

      // Create schema on the new database
      await this.createTenantSchema(databaseName);

      // Run migrations automatically after schema creation
      await this.runTenantMigrations(databaseName);

      // Seed initial user AFTER migrations complete
      if (seedData) {
        await this.seedInitialUser(databaseName, seedData);
      }
    } catch (error) {
      this.logger.error(`Error creating database ${databaseName}:`, error);
      throw error;
    } finally {
      client.release();
    }
  }

  private async createTenantSchema(databaseName: string): Promise<void> {
    const dbUser = this.configService.get<string>('DB_USER') || 'hrapp';
    const dbPassword = this.configService.get<string>('DB_PASSWORD') || 'hrapp123';
    const dbHost = this.configService.get<string>('DB_HOST') || 'localhost';
    const dbPort = this.configService.get<number>('DB_PORT') || 5432;

    const tenantPool = new pg.Pool({
      user: dbUser,
      password: dbPassword,
      host: dbHost,
      port: dbPort,
      database: databaseName,
    });

    const tenantClient = await tenantPool.connect();

    try {
      this.logger.log(`Creating migrations_log table for ${databaseName}...`);

      // ONLY create migrations_log table
      // All other tables will be created by migration files
      await tenantClient.query(`
        CREATE TABLE IF NOT EXISTS "migrations_log" (
          "id" BIGSERIAL PRIMARY KEY,
          "migration_name" VARCHAR(255) NOT NULL UNIQUE,
          "executed_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          "status" VARCHAR(50) DEFAULT 'SUCCESS'
        );
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "idx_migrations_log_name" ON "migrations_log"("migration_name");
      `);

      this.logger.log(`‚úÖ migrations_log table created - ready for migrations`);
    } catch (error) {
      this.logger.error(`Error creating migrations_log for ${databaseName}:`, error);
      throw error;
    } finally {
      tenantClient.release();
      await tenantPool.end();
    }
  }

  /**
   * Seed initial admin user after migrations complete
   */
  private async seedInitialUser(
    databaseName: string,
    seedData: {
      email: string;
      firstName: string;
      lastName: string;
      password: string;
      role: string;
    }
  ): Promise<void> {
    const dbUser = this.configService.get<string>('DB_USER') || 'hrapp';
    const dbPassword = this.configService.get<string>('DB_PASSWORD') || 'hrapp123';
    const dbHost = this.configService.get<string>('DB_HOST') || 'localhost';
    const dbPort = this.configService.get<number>('DB_PORT') || 5432;

    const tenantPool = new pg.Pool({
      user: dbUser,
      password: dbPassword,
      host: dbHost,
      port: dbPort,
      database: databaseName,
    });

    const tenantClient = await tenantPool.connect();

    try {
      this.logger.log(`Creating minimal schema for ${databaseName}...`);

      // Create migrations_log table FIRST so we can track migrations
      await tenantClient.query(`
        CREATE TABLE IF NOT EXISTS "migrations_log" (
          "id" BIGSERIAL PRIMARY KEY,
          "migration_name" VARCHAR(255) NOT NULL UNIQUE,
          "executed_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          "status" VARCHAR(50) DEFAULT 'SUCCESS'
        );
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "idx_migrations_log_name" ON "migrations_log"("migration_name");
      `);

      this.logger.log(`migrations_log table created for ${databaseName}`);

      // Create Role enum
      await tenantClient.query(`
        DO $$ BEGIN
          CREATE TYPE "Role" AS ENUM ('ADMIN', 'HR', 'MANAGER', 'EMPLOYEE');
        EXCEPTION
          WHEN duplicate_object THEN null;
        END $$;
      `);

      // Create SalaryChangeType enum
      await tenantClient.query(`
        DO $$ BEGIN
          CREATE TYPE "SalaryChangeType" AS ENUM ('INITIAL', 'PROMOTION', 'GRADE_ADJUSTMENT', 'PERFORMANCE_INCREASE', 'MARKET_ADJUSTMENT', 'DEPARTMENT_TRANSFER', 'POSITION_CHANGE', 'ANNUAL_INCREMENT');
        EXCEPTION
          WHEN duplicate_object THEN null;
        END $$;
      `);

      // Create users table (minimal, migrations will add more if needed)
      await tenantClient.query(`
        CREATE TABLE IF NOT EXISTS "users" (
          "id" BIGSERIAL NOT NULL,
          "email" TEXT NOT NULL UNIQUE,
          "password" TEXT NOT NULL,
          "firstName" TEXT NOT NULL,
          "lastName" TEXT NOT NULL,
          "role" "Role" NOT NULL DEFAULT 'EMPLOYEE',
          "isActive" BOOLEAN NOT NULL DEFAULT true,
          "deletedAt" TIMESTAMP(3),
          "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          CONSTRAINT "users_pkey" PRIMARY KEY ("id")
        );
      `);

      this.logger.log(`users table created for ${databaseName}`);

      // Create employees table (minimal, migrations will add more if needed)
      await tenantClient.query(`
        CREATE TABLE IF NOT EXISTS "employees" (
          "id" BIGSERIAL NOT NULL,
          "userId" BIGINT,
          "managerId" BIGINT,
          
          -- Basic Information
          "firstName" TEXT NOT NULL,
          "lastName" TEXT NOT NULL,
          "position" TEXT NOT NULL,
          "department" TEXT NOT NULL,
          "joinDate" TIMESTAMP(3) NOT NULL,
          
          -- Personal Information
          "employeeNumber" TEXT UNIQUE,
          "dateOfBirth" TIMESTAMP(3),
          "gender" TEXT,
          "maritalStatus" TEXT,
          "nationality" TEXT,
          "religion" TEXT,
          "bloodType" TEXT,
          "idNumber" TEXT UNIQUE,
          "taxNumber" TEXT UNIQUE,
          
          -- Contact Information
          "phoneNumber" TEXT,
          "alternativePhone" TEXT,
          "address" TEXT,
          "city" TEXT,
          "province" TEXT,
          "postalCode" TEXT,
          "emergencyContactName" TEXT,
          "emergencyContactPhone" TEXT,
          "emergencyContactRelation" TEXT,
          
          -- Bank Information
          "bankName" TEXT,
          "bankAccountNumber" TEXT,
          "bankAccountName" TEXT,
          
          -- Employment Details
          "employmentStatus" TEXT,
          "contractStartDate" TIMESTAMP(3),
          "contractEndDate" TIMESTAMP(3),
          "workLocation" TEXT,
          "baseSalary" NUMERIC(15, 2),
          
          -- Profile
          "profilePicture" TEXT,
          
          -- Status & Audit
          "isActive" BOOLEAN NOT NULL DEFAULT true,
          "deletedAt" TIMESTAMP(3),
          "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          
          CONSTRAINT "employees_pkey" PRIMARY KEY ("id"),
          CONSTRAINT "employees_userId_unique" UNIQUE ("userId"),
          CONSTRAINT "employees_managerId_fk" FOREIGN KEY ("managerId") REFERENCES "employees"("id") ON DELETE SET NULL
        );
      this.logger.log(`employees table created for ${databaseName}`);

      `);

      // Create indexes
      await tenantClient.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS "users_email_key" ON "users"("email");
      `);

      await tenantClient.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS "employees_userId_unique" ON "employees"("userId");
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "employees_firstName_idx" ON "employees"("firstName");
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "employees_lastName_idx" ON "employees"("lastName");
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "employees_position_idx" ON "employees"("position");
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "employees_department_idx" ON "employees"("department");
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "employees_managerId_idx" ON "employees"("managerId");
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "employees_isActive_idx" ON "employees"("isActive");
      `);

      await tenantClient.query(`
        CREATE INDEX IF NOT EXISTS "employees_deletedAt_idx" ON "employees"("deletedAt");
      `);

      // Create foreign key
      await tenantClient.query(`
        DO $$ BEGIN
          ALTER TABLE "employees" ADD CONSTRAINT "employees_userId_fkey" 
            FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
        EXCEPTION
          WHEN duplicate_object THEN null;
        END $$;
      `);

      this.logger.log(`Basic schema structure created for ${databaseName}`);

      // Seed initial user if seedData provided
      if (seedData) {
        try {
          const insertResult = await tenantClient.query(
            `
            INSERT INTO "users" ("email", "firstName", "lastName", "password", "role", "isActive", "createdAt", "updatedAt")
            VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW());
            `,
            [
              seedData.email,
              seedData.firstName,
              seedData.lastName,
              seedData.password,
              'ADMIN',
              true,
            ],
          );
          this.logger.log(
            `Initial user seeded for database ${databaseName} with email: ${seedData.email}, rows affected: ${insertResult.rowCount}`,
          );
        } catch (seedError) {
          this.logger.error(
            `Error seeding user to database ${databaseName}:`,
            seedError,
          );
          throw seedError;
        }
      }

      this.logger.log(`Schema created successfully for database ${databaseName}`);
    } catch (error) {
      this.logger.error(`Error creating schema for database ${databaseName}:`, error);
      throw error;
    } finally {
      tenantClient.release();
      await tenantPool.end();
    }
  }

  async deleteTenantDatabase(tenantSlug: string): Promise<void> {
    const databaseName = `${tenantSlug}_erp`;
    const client = await this.pool.connect();

    try {
      // Terminate all connections to the database
      await client.query(
        `SELECT pg_terminate_backend(pg_stat_activity.pid)
         FROM pg_stat_activity
         WHERE pg_stat_activity.datname = $1
         AND pid <> pg_backend_pid()`,
        [databaseName],
      );

      // Drop database
      await client.query(`DROP DATABASE IF EXISTS "${databaseName}"`);
      this.logger.log(`Database ${databaseName} deleted successfully`);
    } catch (error) {
      this.logger.error(`Error deleting database ${databaseName}:`, error);
      throw error;
    } finally {
      client.release();
    }
  }

  private async runTenantMigrations(databaseName: string): Promise<void> {
    const dbUser = this.configService.get<string>('DB_USER') || 'hrapp';
    const dbPassword = this.configService.get<string>('DB_PASSWORD') || 'hrapp123';
    const dbHost = this.configService.get<string>('DB_HOST') || 'localhost';
    const dbPort = this.configService.get<number>('DB_PORT') || 5432;

    const tenantPool = new pg.Pool({
      user: dbUser,
      password: dbPassword,
      host: dbHost,
      port: dbPort,
      database: databaseName,
    });

    try {
      this.logger.log(`Running migrations for database ${databaseName}...`);

      // Get all migration directories
      const migrationsDir = path.join(process.cwd(), 'prisma', 'migrations-tenant');
      
      if (!fs.existsSync(migrationsDir)) {
        this.logger.warn(`Migrations directory not found: ${migrationsDir}`);
        return;
      }

      const migrationFolders = fs
        .readdirSync(migrationsDir, { withFileTypes: true })
        .filter(entry => entry.isDirectory())
        .map(entry => entry.name)
        .sort();

      this.logger.log(`Found ${migrationFolders.length} migration(s) to run`);

      // Run each migration
      for (const folder of migrationFolders) {
        const migrationFile = path.join(migrationsDir, folder, 'migration.sql');
        
        if (!fs.existsSync(migrationFile)) {
          this.logger.warn(`Migration file not found: ${migrationFile}`);
          continue;
        }

        const migrationSQL = fs.readFileSync(migrationFile, 'utf-8');
        
        try {
          // Check if migration already executed
          const checkResult = await tenantPool.query(
            `SELECT 1 FROM migrations_log WHERE migration_name = $1 LIMIT 1`,
            [folder]
          );

          if (checkResult.rows.length > 0) {
            this.logger.log(`  ‚è≠Ô∏è  ${folder} (already executed)`);
            continue;
          }

          this.logger.log(`  üîÑ Running ${folder}...`);
          
          // Execute migration SQL
          await tenantPool.query(migrationSQL);

          // Record migration
          await tenantPool.query(
            `INSERT INTO migrations_log (migration_name, executed_at) VALUES ($1, NOW())`,
            [folder]
          );

          this.logger.log(`  ‚úÖ ${folder} completed`);
        } catch (error: any) {
          // Ignore certain "already exists" errors
          if (
            error.code === '42P07' || // relation already exists
            error.code === '42710' || // object already exists
            error.code === '42P01' // migrations_log table doesn't exist yet (will be created by migration)
          ) {
            this.logger.log(`  ‚ö†Ô∏è  ${folder} (object already exists, continuing...)`);
            
            // Try to record migration even if table didn't exist before
            try {
              await tenantPool.query(
                `INSERT INTO migrations_log (migration_name, executed_at) VALUES ($1, NOW()) ON CONFLICT (migration_name) DO NOTHING`,
                [folder]
              );
            } catch (recordError) {
              // Ignore if we can't record yet
            }
            continue;
          }

          this.logger.error(`  ‚ùå ${folder} failed:`, error.message);
          throw error;
        }
      }

      this.logger.log(`‚úÖ All migrations completed for ${databaseName}`);
    } catch (error) {
      this.logger.error(`Error running migrations for ${databaseName}:`, error);
      throw error;
    } finally {
      await tenantPool.end();
    }
  }

  async databaseExists(tenantSlug: string): Promise<boolean> {
    const databaseName = `${tenantSlug}_erp`;
    const client = await this.pool.connect();

    try {
      const result = await client.query(
        `SELECT 1 FROM pg_database WHERE datname = $1`,
        [databaseName],
      );
      return result.rows.length > 0;
    } catch (error) {
      this.logger.error(`Error checking database existence:`, error);
      throw error;
    } finally {
      client.release();
    }
  }

  async onModuleDestroy() {
    await this.pool.end();
  }
}
